<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>My Robotics Portfolio</title>
  <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/meyer-reset/2.0/reset.min.css">
  <link rel="stylesheet" href="style.css">
</head>
<body>

  <div class="container">
    <div class="topnav">
      <a href="Resume.html">About Me</a>
      <a href="Projects.html">Projects</a>
      <a href="Contact.html">Contact</a>
    </div>

      <div class="project-title">
        <div class="my-name">Master's Project</div>
        <div class="my-title">Assembly and Implentation of a walk algorithm on a 8-DOF quadruped robot</div>

        <div><img src="img/SOLO.png" class="image"></div>

        <h1>Introduction</h1>
        This project is a team Master's project for the ISAE-Supaero MSc in Aerospace & Aeronautics Engineering year.
      </br> It is a demanding project since we have to deal with a client, the LAAS-CNRS, as we would do in a real company.
    </br></br> The goal of this project is to assemble and implement a walk on a 8-DOF quadruped robot for the LAAS-CNRS lab based on what has been done by the Max Planck Institute in Germany.

        <h1>Assembling the robot</h1>
        The first activity we had to carry out for our client, the LAAS-CNRS, was to assemble the robot by following a detailed assembly protocol.
        The assembly of the robot is quite demanding because our client wanted to keep joint mechanical friction as low as possible in order to maximize the reactivity of the robot.

      </br></br> Since the assembly of the robot is quite demanding and because we have limited time dedicated to this project, the final assembly is scheduled for January 2020.

    </br></br> Here is an excerpt of the assembly procedure needed corresponding to the preparation of the shells of the legs:
    <img class="image" src="img/shell_fasteners.png"  >
    <img class="image" src="img/shell_preparation.png"  >


        <h1>Designing a trajectory and implementing a controller</h1>
        <h2>Inverse kinematics </h2>
        The first step to designing a trajectory for the leg of the robot was to compute what we call the inverse kinematics.
        Indeed, we wanted to control the position of the tip of the leg in the x-z plan instead of the angles.
        Therefore, we had to determine the angles corresponding to a position of the tip of a leg: this is what we called the inverse kinematics.

        <h2>Designing a trajectory</h2>
        We wanted to test several methods to design a trajectory. The first approach was the geometric approach: we just design a trajectory in the x-y plan as following:
        <img class="image" src="img/trajectory.png">
        This approach is quite simple but requires to determine timely commands x(t) and y(t) from the x-y trajectory such that x(t), y(t), vx(t) and vy(t) are continuous functions.

      </br></br> The second approach we tested was the Fourrier Series appoach. In this approach, we tried to generate the x(t) and y(t) signals such that the x-y approximate the previous x-y trajectory.
        We have noticed that this method is a powerful method because it is quite easy to implement and it produces satisfying results quickly.

      </br> </br> For example, here is the first trajectory we generated using Fourrier Series:
        <img src="img/fourrier.png" class="image">
        This x-y trajectory was generate only a few lines of code in Python:
        <pre><code>
import numpy as np
import matplotlib.pyplot as plt
t = np.arange(start=0,stop=10,step=0.1)
x=np.sin(t)
y=np.sin(t-np.pi/2)-0.27*np.sin(2*t-np.pi/2)

</code></pre>

Therefore we directly have x(t) and y(t):

<img class="image" src="img/x(t).png">
<img class="image" src="img/y(t).png">

The third approach that we are testing is the Bezier curves approach which is quite similar to the geometric approach.

</br> </br> Moreover, we have tried to parametrize our trajectory in order to optimize them with an organic algorithm.

        <h2>Implementing the controller to generate the walk</h2>
        Several files have been use to generate the controller and the trajectory. But the main idea is that the trajectory is generated by the x(t) and y(t) functions that
        we have determined thanks to the previous approach.

      </br></br> After that, a PID controller that we first generated and tested on Matlab/Simulink is implemented to generate the torques required to reach the desired x and y positions. Here is a simplified model we used:

        <img src="img/Matlab-SOLO.png">
        <h1>Implementation on the robot and testing</h1>
        The LAAS-CNRS provided us with a full simulation environment so we could test and optimize different walk algorithms.
        We have tested a few promising gaits by simulation. Here is the first walk we implemented in the simulation in October 2019:
        <img class="image" src="img/jumping-walk.gif">

        <h1>Results</h1>
        Simulations seem quite promissing promising after only 2 months on the project.
        Test will be run on a real robot in January.

      </br></br> The genetic algorithm is being implemented and tested for the moment, we expect to be able to deploy on
        AWS in order to have enough computing power to optimize our trajectories.

        <h1>Future Work</h1>
        In the coming weeks/months, we will have to complete the assembly of the robot with the missing pieces.
        We will also try to optimize the trajectories generated and test the results of the optimization on the simulation and on the robot.
        Finally, we will have to optimize the genetic algorithm in order to make it faster so that we can improve the quality of the optimization.












        </br> </br>





      </div>











  </div>
</body>
</html>
